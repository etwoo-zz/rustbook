cargo check

    like compiling but does not produce executable

type declaration for array

    let a: [i32; 5] = [1, 2, 3, 4, 5];
                 ^ number of elements
            ^^^
            type of each element

statements (do not return value) vs expressions (evaluate to resulting value)

    fn main() {
        let x = 5;

        let y = {
            let x = 3;
            x + 1
        };

        println!("The value of y is: {}", y);
    }

    This expression:

    {
        let x = 3;
        x + 1
    }

    is a block that, in this case, evaluates to 4. That value gets bound
    to y as part of the let statement. Note the x + 1 line without a
    semicolon at the end, which is unlike most of the lines you've seen
    so far. Expressions do not include ending semicolons. If you add a
    semicolon to the end of an expression, you turn it into a statement,
    which will then not return a value.

control flow: more expression usage

    Because `if` is an expression, we can use it on the right side of a
    `let` statement [...]

    fn main() {
        let condition = true;
        let number = if condition {
            5
        } else {
            6
        };

        println!("The value of number is: {}", number);
    }

    The number variable will be bound to a value based on the outcome of
    the `if` expression.

    [...] you can add the value you want returned after the `break`
    expression you use to stop the loop; that value will be returned
    out of the loop so you can use it, as shown here:

    fn main() {
        let mut counter = 0;

        let result = loop {
            counter += 1;

            if counter == 10 {
                break counter * 2;
            }
        };

        println!("The result is {}", result);
    }

struct update syntax, like a refined copy constructor syntax

    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };

    Using struct update syntax, we can achieve the same effect with less
    code [...] The syntax `..` specifies that the remaining fields not
    explicitly set should have the same value as the fields in the given
    instance.

    let user2 = User {
        email: String::from("another@example.com"),
        username: String::from("anotherusername567"),
        ..user1
    };
